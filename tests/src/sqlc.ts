// This file was generated by sqlc-typescript
// Do not modify this file by hand

import { UUID } from '../types';

type Json = JsonPrimitive | Json[] | { [key: string]: Json };
type JsonPrimitive = string | number | boolean | null;

type QueryClient = {
    query: (
        query: string,
        params: unknown[],
    ) => Promise<{
        rows: Array<Record<string, unknown>>;
    }>;
};

type Override<TSpec, TRow> = Partial<{
    [K in keyof TSpec]: K extends keyof TRow ? TSpec[K] : never;
}>;

type ApplyOverride<TSpec, TRow> = {
    [K in keyof TRow]: K extends keyof TSpec ? TSpec[K] : TRow[K];
};

type ExecFn<TRow, TParam> = [TParam] extends [never]
    ? <TSpec extends Override<TSpec, TRow>>(client: QueryClient) => Promise<Array<ApplyOverride<TSpec, TRow>>>
    : <TSpec extends Override<TSpec, TRow>>(
          client: QueryClient,
          params: TParam & Record<string, unknown>,
      ) => Promise<Array<ApplyOverride<TSpec, TRow>>>;

type SqlType<T, TDbType, TDbSource> = T & {
    /**
     * @deprecated this property does not exist in runtime, it is used for type-checking, do not use it in runtime!
     */
    __dbtype: TDbType;

    /**
     * @deprecated this property does not exist in runtime, it is used for type-checking, do not use it in runtime!
     */
    __dbsource: TDbSource;
};

class Query<TRow, TParam> {
    public query;
    public params;

    public constructor(query: string, params: string[]) {
        this.query = query;
        this.params = params;
    }

    public exec = (async (client, params) => {
        const { rows } = await client.query(
            this.query,
            this.params.map((param) => params[param]),
        );

        return rows;
    }) as ExecFn<TRow, TParam>;
}

type Queries = typeof queries;

const queries = {
    [`
    SELECT
        first_name,
        last_name,
        email,
        address_id,
        store_id,
        activebool,
        create_date,
        last_update
    FROM
        customer
    WHERE
        customer_id = @customer_id
`]: new Query<
        {
            first_name: SqlType<string, 'text', 'customer.first_name'>;
            last_name: SqlType<string, 'text', 'customer.last_name'>;
            email: SqlType<string, 'text', 'customer.email'> | null;
            address_id: SqlType<number, 'int4', 'customer.address_id'>;
            store_id: SqlType<number, 'int4', 'customer.store_id'>;
            activebool: SqlType<boolean, 'bool', 'customer.activebool'>;
            create_date: SqlType<Date, 'date', 'customer.create_date'>;
            last_update: SqlType<Date, 'timestamptz', 'customer.last_update'> | null;
        },
        { customer_id: UUID }
    >(
        `SELECT
        first_name,
        last_name,
        email,
        address_id,
        store_id,
        activebool,
        create_date,
        last_update
    FROM
        customer
    WHERE
        customer_id = $1`,
        ['customer_id'],
    ),
    [`
    SELECT
        film_id,
        title,
        description,
        release_year,
        rental_rate
    FROM
        film
    WHERE
        title LIKE '%' || @film_title || '%';
`]: new Query<
        {
            film_id: SqlType<number, 'int4', 'film.film_id'>;
            title: SqlType<string, 'text', 'film.title'>;
            description: SqlType<string, 'text', 'film.description'> | null;
            release_year: SqlType<unknown, 'year', 'film.release_year'> | null;
            rental_rate: SqlType<number, 'numeric', 'film.rental_rate'>;
        },
        { film_title: string | null }
    >(
        `SELECT
        film_id,
        title,
        description,
        release_year,
        rental_rate
    FROM
        film
    WHERE
        title LIKE '%' || $1 || '%'`,
        ['film_title'],
    ),
    [`
    SELECT
        r.rental_id,
        r.rental_date,
        f.title AS film_title,
        r.return_date
    FROM
        rental AS r
    JOIN
        inventory AS i ON r.inventory_id = i.inventory_id
    JOIN
        film AS f ON i.film_id = f.film_id
    WHERE
        r.customer_id = @customer_id
    ORDER BY
        r.rental_date DESC;
`]: new Query<
        {
            rental_id: SqlType<number, 'int4', 'rental.rental_id'>;
            rental_date: SqlType<Date, 'timestamptz', 'rental.rental_date'>;
            film_title: SqlType<string, 'text', 'film.title'>;
            return_date: SqlType<Date, 'timestamptz', 'rental.return_date'> | null;
        },
        { customer_id: number }
    >(
        `SELECT
        r.rental_id,
        r.rental_date,
        f.title AS film_title,
        r.return_date
    FROM
        rental AS r
    JOIN
        inventory AS i ON r.inventory_id = i.inventory_id
    JOIN
        film AS f ON i.film_id = f.film_id
    WHERE
        r.customer_id = $1
    ORDER BY
        r.rental_date DESC`,
        ['customer_id'],
    ),
    [`
    SELECT
        customer_id,
        COUNT(*) AS rental_count
    FROM
        rental
    GROUP BY
        customer_id
    HAVING
        customer_id = @customer_id
`]: new Query<
        { customer_id: SqlType<number, 'int4', 'rental.customer_id'>; rental_count: SqlType<number, 'bigint', never> },
        { customer_id: number }
    >(
        `SELECT
        customer_id,
        COUNT(*) AS rental_count
    FROM
        rental
    GROUP BY
        customer_id
    HAVING
        customer_id = $1`,
        ['customer_id'],
    ),
    [`
    WITH CategoryRevenue AS (
        SELECT
            c.name AS category_name,
            SUM(p.amount) AS total_revenue
        FROM
            category AS c
        JOIN
            film_category AS fc ON c.category_id = fc.category_id
        JOIN
            film AS f ON fc.film_id = f.film_id
        JOIN
            inventory AS i ON f.film_id = i.film_id
        JOIN
            rental AS r ON i.inventory_id = r.inventory_id
        JOIN
            payment AS p ON r.rental_id = p.rental_id
        GROUP BY
            c.name
    )
    SELECT
        category_name,
        total_revenue
    FROM
        CategoryRevenue
    ORDER BY
        total_revenue DESC
    LIMIT 5
`]: new Query<
        {
            category_name: SqlType<string, 'text', 'categoryrevenue.category_name'>;
            total_revenue: SqlType<number, 'bigint', 'categoryrevenue.total_revenue'>;
        },
        never
    >(
        `WITH CategoryRevenue AS (
        SELECT
            c.name AS category_name,
            SUM(p.amount) AS total_revenue
        FROM
            category AS c
        JOIN
            film_category AS fc ON c.category_id = fc.category_id
        JOIN
            film AS f ON fc.film_id = f.film_id
        JOIN
            inventory AS i ON f.film_id = i.film_id
        JOIN
            rental AS r ON i.inventory_id = r.inventory_id
        JOIN
            payment AS p ON r.rental_id = p.rental_id
        GROUP BY
            c.name
    )
    SELECT
        category_name,
        total_revenue
    FROM
        CategoryRevenue
    ORDER BY
        total_revenue DESC
    LIMIT 5`,
        [],
    ),
};

export type mpaa_rating = 'G' | 'PG' | 'PG-13' | 'R' | 'NC-17';

export const sqlc = <T extends keyof Queries>(query: T) => queries[query];
