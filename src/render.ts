import type { Column, Config, SqlcResult } from './types.ts';

export const generate_types = ({
    sqlc_result,
    queries,
    config,
}: {
    queries: Map<string, string>;
    sqlc_result: SqlcResult;
    config: Pick<Config, 'types' | 'columns'>;
}) => {
    const { schema_types, schema_types_content } = get_schema_types(sqlc_result);
    const lines = [];

    for (const query of sqlc_result.queries) {
        const original = queries.get(query.name);
        let line = `[\`${original}\`]: new Query<`;

        if (query.columns.length > 0) {
            line += `{ `;
            line += query.columns
                .map((column) => {
                    return `"${column.name}": ${column_to_tstype({ column, config, schema_types, branded: true })}`;
                })
                .join(';');
            line += ` },`;
        } else {
            line += `never, `;
        }

        if (query.params.length > 0) {
            line += `{`;
            line += query.params
                .map((param) => {
                    return `"${param.column.name}": ${column_to_tstype({ column: param.column, config, schema_types, branded: false })}`;
                })
                .join(';');
            line += `}`;
        } else {
            line += `never`;
        }

        line += `>(\`${query.text.trim()}\`, [${query.params
            .sort((a, b) => a.number - b.number)
            .map((param) => `'${param.column.name}'`)
            .join(', ')}]),`;

        lines.push(line);
    }

    return {
        queries_content: lines.join('\n'),
        schema_types_content,
    };
};

export const get_schema_types = (output: SqlcResult) => {
    const lines: string[] = [];
    const schema_types = new Set<string>();

    for (const schema of output.catalog.schemas) {
        if (schema.composite_types.length === 0 && schema.enums.length === 0) {
            continue;
        }

        if (schema.name !== 'public') {
            lines.push(`namespace ${schema.name} {`);
        }

        for (const e of schema.enums) {
            if (e.comment !== '') {
                lines.push(`/** ${e.comment} */`);
            }

            lines.push(`export type ${e.name} = ${e.vals.map((v) => `'${v}'`).join(' | ')};`);
            schema_types.add([schema.name, e.name].join('.'));
        }

        for (const ct of schema.composite_types) {
            if (ct.comment !== '') {
                lines.push(`/** ${ct.comment} */`);
            }

            lines.push(`export type ${ct.name} = unknown;`);
            schema_types.add([schema.name, ct.name].join('.'));
        }

        if (schema.name !== 'public') {
            lines.push('}');
        }

        lines.push('');
    }

    return { schema_types, schema_types_content: lines.join('\n') };
};

const column_to_tstype = ({
    column,
    schema_types,
    config,
    branded,
}: {
    column: Column;
    schema_types: Set<string>;
    config: Pick<Config, 'types' | 'columns'>;
    branded: boolean;
}) => {
    let type = get_column_type({ config, column, schema_types, branded });

    if (column.is_array) {
        type = `Array<${type}>`;
    }

    if (!column.not_null) {
        type += ' | null';
    }

    return type;
};

const get_column_type = ({
    column,
    schema_types,
    config,
    branded,
}: {
    column: Column;
    schema_types: Set<string>;
    config: Pick<Config, 'types' | 'columns'>;
    branded: boolean;
}) => {
    const source = [
        ...[column.table?.schema, ...(column.table?.name.split('.') ?? [])].filter(
            (x) => x != null && x !== '' && x !== 'public' && x !== 'pg_catalog',
        ),
        column.original_name,
    ].join('.');

    const parts = [column.type.schema, column.type.name.split('.')]
        .flat()
        .filter((x) => x != null && x !== '' && x !== 'public' && x !== 'pg_catalog');

    const db_type = parts.join('.');

    const final_type = (() => {
        if (config.columns[source]) {
            return config.columns[source];
        }

        if (schema_types.has(db_type)) {
            return [column.type.schema, column.type.name].join('.');
        }

        return DEFAULT_TYPES[db_type] || config.types[db_type] || DEFAULT_TYPES[db_type] || 'unknown';
    })();

    if (branded) {
        const final_source = source !== '' ? `'${source}'` : 'never';
        return `SqlType<${final_type}, '${db_type}', ${final_source}>`;
    }

    return final_type;
};

export const render_template = ({
    queries_content,
    schema_types_content,
    header = '// This file was generated by sqlc-typescript\n// Do not modify this file by hand\n',
    imports,
}: {
    queries_content: string;
    schema_types_content?: string;
    header?: string;
    imports: string[];
}) => /* ts */ `
${header}

${imports.map((x) => (x.trim().endsWith(';') ? x : x + ';')).join('\n')}

type Json = JsonPrimitive | Json[] | { [key: string]: Json };
type JsonPrimitive = string | number | boolean | null;

type QueryClient = {
    query: (
        query: string,
        params: unknown[],
    ) => Promise<{
        rows: Array<Record<string, unknown>>;
    }>;
};

type Override<TSpec, TRow> = Partial<{
    [K in keyof TSpec]: K extends keyof TRow ? TSpec[K] : never;
}>;

type ApplyOverride<TSpec, TRow> = {
    [K in keyof TRow]: K extends keyof TSpec ? TSpec[K] : TRow[K];
};

type ExecFn<TRow, TParam> = [TParam] extends [never]
    ? <TSpec extends Override<TSpec, TRow>>(client: QueryClient) => Promise<Array<ApplyOverride<TSpec, TRow>>>
    : <TSpec extends Override<TSpec, TRow>>(
          client: QueryClient,
          params: TParam & Record<string, unknown>,
      ) => Promise<Array<ApplyOverride<TSpec, TRow>>>;

type SqlType<T, TDbType, TDbSource> = T & {
    /**
     * @deprecated this property does not exist in runtime, it is used for type-checking, do not use it in runtime!
     */
    __dbtype: TDbType;

    /**
     * @deprecated this property does not exist in runtime, it is used for type-checking, do not use it in runtime!
     */
    __dbsource: TDbSource;
};

class Query<TRow, TParam> {
    public query;
    public params;

    public constructor(query: string, params: string[]) {
        this.query = query;
        this.params = params;
    }

    public exec = (async (client, params) => {
        const { rows } = await client.query(
            this.query,
            this.params.map((param) => params[param]),
        );

        return rows;
    }) as ExecFn<TRow, TParam>;
}

type Queries = typeof queries;

const queries = {
${queries_content || '    // no queries found'}
};

${schema_types_content || '// no types found'}

export const sqlc = <T extends keyof Queries>(query: T) => queries[query];
`;

export const DEFAULT_TYPES: Record<string, string> = {
    // Text types
    text: 'string',
    varchar: 'string',
    char: 'string',
    citext: 'string',
    name: 'string',

    // Numeric types
    int2: 'number',
    int4: 'number',
    int8: 'number',
    smallint: 'number',
    integer: 'number',
    bigint: 'number',
    decimal: 'number',
    numeric: 'number',
    real: 'number',
    float4: 'number',
    float8: 'number',
    double: 'number',
    money: 'number',

    // Boolean type
    bool: 'boolean',
    boolean: 'boolean',

    // Date/Time types
    date: 'Date',
    timestamp: 'Date',
    timestamptz: 'Date',
    time: 'string',
    timetz: 'string',
    interval: 'string',

    // JSON types
    json: 'Json',
    jsonb: 'Json',

    // UUID
    uuid: 'string',

    // Network address types
    inet: 'string',
    cidr: 'string',
    macaddr: 'string',
    macaddr8: 'string',

    // Geometric types
    point: 'string',
    line: 'string',
    lseg: 'string',
    box: 'string',
    path: 'string',
    polygon: 'string',
    circle: 'string',

    // Binary data
    bytea: 'Buffer',

    // Arrays
    _text: 'string[]',
    _varchar: 'string[]',
    _int2: 'number[]',
    _int4: 'number[]',
    _int8: 'number[]',
    _float4: 'number[]',
    _float8: 'number[]',
    _bool: 'boolean[]',
    _date: 'Date[]',
    _timestamp: 'Date[]',
    _timestamptz: 'Date[]',
    _json: 'unknown[]',
    _jsonb: 'unknown[]',
    _uuid: 'string[]',

    // Other common types
    bit: 'string',
    varbit: 'string',
    tsvector: 'string',
    tsquery: 'string',
    xml: 'string',
    enum: 'string',
    oid: 'number',
};
