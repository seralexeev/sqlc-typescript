
// This file was generated by sqlc-typescript
// Do not modify this file by hand


import type { UUID } from './types.ts';

type Json = JsonPrimitive | Json[] | { [key: string]: Json };
type JsonPrimitive = string | number | boolean | null;

type QueryClient = {
    query: (
        query: string,
        params?: unknown[],
    ) => Promise<{
        rows: Array<Record<string, unknown>>;
    }>;
};

type Apply<T, K extends keyof T, TOverride> = K extends keyof TOverride ? TOverride[K] : T[K];

type Queries = typeof queries;

const queries = {
    ["\n                SELECT\n                    customer_id,\n                    store_id\n                FROM customer\n            "]: {
        exec: async<TOverride extends Partial<{ "customer_id": unknown; "store_id": unknown }> = {}>(client: QueryClient) => {
            type Row = { "customer_id": UUID; "store_id": number };
            const { rows } = await client.query("SELECT\n    customer_id,\n    store_id\nFROM customer");
            return rows as unknown as Array<{ "customer_id": Apply<Row, 'customer_id', TOverride>; "store_id": Apply<Row, 'store_id', TOverride> }>;
        },
        type: 'flat',
    },
    ["\n                SELECT\n                    c.customer_id AS id,\n                    c.first_name,\n                    c.last_name,\n                    s.manager_staff_id AS \"store.manager_staff_id\",\n                    a.address_id AS \"store.address.id\",\n                    a.address AS \"store.address.address\",\n                    a.address2 AS \"store.address.address2\"\n                FROM customer AS c\n                JOIN store AS s ON c.store_id = s.store_id\n                JOIN address AS a ON c.address_id = a.address_id\n                WHERE customer_id = @customer_id\n            "]: {
        exec: async<TOverride extends Partial<{ "id": unknown; "first_name": unknown; "last_name": unknown; "store.manager_staff_id": unknown; "store.address.id": unknown; "store.address.address": unknown; "store.address.address2": unknown }> = {}>(client: QueryClient, params: { "customer_id": UUID }) => {
            type Row = { "id": UUID; "first_name": string; "last_name": string; "store.manager_staff_id": number; "store.address.id": number; "store.address.address": string; "store.address.address2": string | null };
            const { rows } = await client.query("SELECT\n    c.customer_id AS id,\n    c.first_name,\n    c.last_name,\n    s.manager_staff_id AS \"store.manager_staff_id\",\n    a.address_id AS \"store.address.id\",\n    a.address AS \"store.address.address\",\n    a.address2 AS \"store.address.address2\"\nFROM customer AS c\nJOIN store AS s ON c.store_id = s.store_id\nJOIN address AS a ON c.address_id = a.address_id\nWHERE customer_id = $1", (["customer_id"] as const).map((param) => params[param]));
            return unflatten_sql_results(rows as unknown as SqlRow[], {"id":{"type":"value","original_name":"id"},"first_name":{"type":"value","original_name":"first_name"},"last_name":{"type":"value","original_name":"last_name"},"store":{"type":"object","properties":{"manager_staff_id":{"type":"value","original_name":"store.manager_staff_id"},"address":{"type":"object","properties":{"id":{"type":"value","original_name":"store.address.id"},"address":{"type":"value","original_name":"store.address.address"},"address2":{"type":"value","original_name":"store.address.address2"}},"original_name":"store.address.id"}},"original_name":"store.manager_staff_id"}}) as unknown as Array<{ id: Apply<Row, 'id', TOverride>;first_name: Apply<Row, 'first_name', TOverride>;last_name: Apply<Row, 'last_name', TOverride>;store: { manager_staff_id: Apply<Row, 'store.manager_staff_id', TOverride>;address: { id: Apply<Row, 'store.address.id', TOverride>;address: Apply<Row, 'store.address.address', TOverride>;address2: Apply<Row, 'store.address.address2', TOverride> } } }>;
        },
        type: 'nested',
    },
    ["\n            WITH customer_spending AS (\n                SELECT \n                    c.customer_id,\n                    c.first_name,\n                    c.last_name,\n                    COUNT(r.rental_id) as total_rentals,\n                    SUM(p.amount) as total_spent,\n                    AVG(p.amount) as avg_payment\n                FROM customer c\n                JOIN rental r ON c.customer_id = r.customer_id\n                JOIN payment p ON r.rental_id = p.rental_id\n                GROUP BY c.customer_id, c.first_name, c.last_name\n            ),\n            customer_categories AS (\n                SELECT DISTINCT\n                    c.customer_id,\n                    STRING_AGG(cat.name, ', ') OVER (PARTITION BY c.customer_id) as favorite_categories\n                FROM customer c\n                JOIN rental r ON c.customer_id = r.customer_id\n                JOIN inventory i ON r.inventory_id = i.inventory_id\n                JOIN film_category fc ON i.film_id = fc.film_id\n                JOIN category cat ON fc.category_id = cat.category_id\n            )\n            SELECT \n                cs.*,\n                cc.favorite_categories,\n                RANK() OVER (ORDER BY cs.total_spent DESC) as spending_rank,\n                NTILE(4) OVER (ORDER BY cs.total_rentals) as rental_quartile,\n                ROUND(cs.total_spent / SUM(cs.total_spent) OVER () * 100, 2) as percentage_of_total_revenue\n            FROM customer_spending cs\n            JOIN customer_categories cc ON cs.customer_id = cc.customer_id\n            WHERE cs.total_rentals > 5\n            ORDER BY spending_rank\n        "]: {
        exec: async<TOverride extends Partial<{ "customer_id": unknown; "first_name": unknown; "last_name": unknown; "total_rentals": unknown; "total_spent": unknown; "avg_payment": unknown; "favorite_categories": unknown; "spending_rank": unknown; "rental_quartile": unknown; "percentage_of_total_revenue": unknown }> = {}>(client: QueryClient) => {
            type Row = { "customer_id": number; "first_name": string; "last_name": string; "total_rentals": number; "total_spent": number; "avg_payment": unknown; "favorite_categories": Buffer; "spending_rank": number; "rental_quartile": number; "percentage_of_total_revenue": number };
            const { rows } = await client.query("WITH customer_spending AS (\n    SELECT \n        c.customer_id,\n        c.first_name,\n        c.last_name,\n        COUNT(r.rental_id) as total_rentals,\n        SUM(p.amount) as total_spent,\n        AVG(p.amount) as avg_payment\n    FROM customer c\n    JOIN rental r ON c.customer_id = r.customer_id\n    JOIN payment p ON r.rental_id = p.rental_id\n    GROUP BY c.customer_id, c.first_name, c.last_name\n),\ncustomer_categories AS (\n    SELECT DISTINCT\n        c.customer_id,\n        STRING_AGG(cat.name, ', ') OVER (PARTITION BY c.customer_id) as favorite_categories\n    FROM customer c\n    JOIN rental r ON c.customer_id = r.customer_id\n    JOIN inventory i ON r.inventory_id = i.inventory_id\n    JOIN film_category fc ON i.film_id = fc.film_id\n    JOIN category cat ON fc.category_id = cat.category_id\n)\nSELECT \n    cs.customer_id, cs.first_name, cs.last_name, cs.total_rentals, cs.total_spent, cs.avg_payment,\n    cc.favorite_categories,\n    RANK() OVER (ORDER BY cs.total_spent DESC) as spending_rank,\n    NTILE(4) OVER (ORDER BY cs.total_rentals) as rental_quartile,\n    ROUND(cs.total_spent / SUM(cs.total_spent) OVER () * 100, 2) as percentage_of_total_revenue\nFROM customer_spending cs\nJOIN customer_categories cc ON cs.customer_id = cc.customer_id\nWHERE cs.total_rentals > 5\nORDER BY spending_rank");
            return rows as unknown as Array<{ "customer_id": Apply<Row, 'customer_id', TOverride>; "first_name": Apply<Row, 'first_name', TOverride>; "last_name": Apply<Row, 'last_name', TOverride>; "total_rentals": Apply<Row, 'total_rentals', TOverride>; "total_spent": Apply<Row, 'total_spent', TOverride>; "avg_payment": Apply<Row, 'avg_payment', TOverride>; "favorite_categories": Apply<Row, 'favorite_categories', TOverride>; "spending_rank": Apply<Row, 'spending_rank', TOverride>; "rental_quartile": Apply<Row, 'rental_quartile', TOverride>; "percentage_of_total_revenue": Apply<Row, 'percentage_of_total_revenue', TOverride> }>;
        },
        type: 'flat',
    },
};

export type mpaa_rating = 'G' | 'PG' | 'PG-13' | 'R' | 'NC-17';


type SchemaNode = {
    type: 'value' | 'object' | 'array';
    properties?: Record<string, SchemaNode>;
    original_name?: string;
};

type SqlRow = {
    [key: string]: unknown;
    '[]': number;
};

type NestedSchema = Record<string, SchemaNode>;

const unflatten_row = (row: SqlRow, schema: NestedSchema): Record<string, unknown> => {
    // Recursive helper function to build nested objects
    const build_object = (schema: NestedSchema, prefix = ''): Record<string, unknown> => {
        const result: Record<string, unknown> = {};

        for (const [key, value] of Object.entries(schema)) {
            const full_key = prefix ? prefix + '.' + key : key;

            // Handle different types from schema
            if (value.type === 'value') {
                // Direct value assignment for regular fields
                result[key] = row[full_key];
            } else if (value.type === 'object' && value.properties) {
                // Recursive object building for nested structures
                result[key] = build_object(value.properties, full_key);
            } else if (value.type === 'array' && value.properties) {
                // Handle array items - create empty array if null, otherwise build object
                const array_index = row[full_key + '[]'];
                if (array_index === null) {
                    result[key] = [];
                } else {
                    result[key] = [build_object(value.properties, full_key + '[]')];
                }
            }
        }

        return result;
    };

    return build_object(schema);
};

interface IdentifiableObject {
    id?: unknown;
    [key: string]: unknown;
}

const merge_objects = (target: IdentifiableObject, source: IdentifiableObject): IdentifiableObject => {
    for (const [key, value] of Object.entries(source)) {
        if (Array.isArray(value)) {
            // Initialize array if doesn't exist
            const target_array = target[key];
            if (!target_array) {
                target[key] = [];
            } else if (!Array.isArray(target_array)) {
                throw new Error('Expected array at key ' + key);
            }

            // Merge array items if not empty
            if (value.length > 0) {
                const first_value = value[0] as IdentifiableObject;
                const target_typed = target[key] as IdentifiableObject[];

                const existing_item = target_typed.find((item) => item.id === first_value.id);

                if (existing_item) {
                    // Merge into existing item if found
                    merge_objects(existing_item, first_value);
                } else {
                    // Add new items if not found
                    target_typed.push(...(value as IdentifiableObject[]));
                }
            }
        } else if (typeof value === 'object' && value !== null) {
            // Handle nested objects recursively
            if (!target[key]) {
                target[key] = {};
            }
            const target_obj = target[key];
            if (typeof target_obj !== 'object' || target_obj === null) {
                throw new Error('Expected object at key ' + key);
            }
            merge_objects(target_obj as IdentifiableObject, value as IdentifiableObject);
        } else {
            // Direct assignment for primitive values
            target[key] = value;
        }
    }
    return target;
};

const unflatten_sql_results = (rows: SqlRow[], schema: NestedSchema): IdentifiableObject[] => {
    if (rows.length === 0) {
        return [];
    }

    // Step 2: Unflatten each row according to schema
    const unflattened_rows = rows.map((row) => unflatten_row(row, schema) as IdentifiableObject);

    // Step 3: Merge rows based on root array indicator
    const result: IdentifiableObject[] = [];
    const root_index_map = new Map<number, number>();

    for (const row of unflattened_rows) {
        const root_index = rows[0]?.['[]'];
        if (typeof root_index !== 'number') {
            throw new Error('Invalid root index');
        }

        const existing_index = root_index_map.get(root_index);
        if (existing_index === undefined) {
            root_index_map.set(root_index, result.length);
            result.push(row);
        } else if (result[existing_index] != null) {
            merge_objects(result[existing_index], row);
        }
    }

    return result;
};

export const sqlc = <T extends keyof Queries>(query: T) => queries[query];
export const sqln = <T extends keyof { [K in keyof Queries]: Queries[K]['type'] extends 'nested' ? K : never; }>(query: T) => queries[query];
