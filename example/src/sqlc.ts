// This file was generated by sqlc-typescript
// Do not modify this file by hand

import type { UUID } from './types.ts';

type Json = JsonPrimitive | Json[] | { [key: string]: Json };
type JsonPrimitive = string | number | boolean | null;

type QueryClient = {
    query: (
        query: string,
        params: unknown[],
    ) => Promise<{
        rows: Array<Record<string, unknown>>;
    }>;
};

type Override<TSpec, TRow> = Partial<{
    [K in keyof TSpec]: K extends keyof TRow ? TSpec[K] : never;
}>;

type ApplyOverride<TSpec, TRow> = {
    [K in keyof TRow]: K extends keyof TSpec ? TSpec[K] : TRow[K];
};

type ExecFn<TRow, TParam> = [TParam] extends [never]
    ? <TSpec extends Override<TSpec, TRow>>(client: QueryClient) => Promise<Array<ApplyOverride<TSpec, TRow>>>
    : <TSpec extends Override<TSpec, TRow>>(
          client: QueryClient,
          params: TParam & Record<string, unknown>,
      ) => Promise<Array<ApplyOverride<TSpec, TRow>>>;

type SqlType<T, TDbType, TDbSource> = T & {
    /**
     * @deprecated this property does not exist in runtime, it is used for type-checking, do not use it in runtime!
     */
    __dbtype: TDbType;

    /**
     * @deprecated this property does not exist in runtime, it is used for type-checking, do not use it in runtime!
     */
    __dbsource: TDbSource;
};

class Query<TRow, TParam> {
    public query;
    public params;

    public constructor(query: string, params: string[]) {
        this.query = query;
        this.params = params;
    }

    public exec = (async (client, params) => {
        const { rows } = await client.query(
            this.query,
            this.params.map((param) => params[param]),
        );

        return rows;
    }) as ExecFn<TRow, TParam>;
}

export type InferRow<T> = T extends Query<infer R, any> ? R : never;
export type InferParam<T> = T extends Query<any, infer P> ? P : never;

type Queries = typeof queries;

const queries = {
    [`
                SELECT
                    customer_id,
                    store_id
                FROM customer
            `]: new Query<
        { customer_id: SqlType<UUID, 'int4', 'customer.customer_id'>; store_id: SqlType<number, 'int4', 'customer.store_id'> },
        never
    >(
        `SELECT
                    customer_id,
                    store_id
                FROM customer`,
        [],
    ),
    [`
                SELECT
                    customer_id,
                    store_id
                FROM customer
                WHERE customer_id = @customer_id
            `]: new Query<
        { customer_id: SqlType<UUID, 'int4', 'customer.customer_id'>; store_id: SqlType<number, 'int4', 'customer.store_id'> },
        { customer_id: UUID }
    >(
        `SELECT
                    customer_id,
                    store_id
                FROM customer
                WHERE customer_id = $1`,
        ['customer_id'],
    ),
    [`
            WITH customer_spending AS (
                SELECT 
                    c.customer_id,
                    c.first_name,
                    c.last_name,
                    COUNT(r.rental_id) as total_rentals,
                    SUM(p.amount) as total_spent,
                    AVG(p.amount) as avg_payment
                FROM customer c
                JOIN rental r ON c.customer_id = r.customer_id
                JOIN payment p ON r.rental_id = p.rental_id
                GROUP BY c.customer_id, c.first_name, c.last_name
            ),
            customer_categories AS (
                SELECT DISTINCT
                    c.customer_id,
                    STRING_AGG(cat.name, ', ') OVER (PARTITION BY c.customer_id) as favorite_categories
                FROM customer c
                JOIN rental r ON c.customer_id = r.customer_id
                JOIN inventory i ON r.inventory_id = i.inventory_id
                JOIN film_category fc ON i.film_id = fc.film_id
                JOIN category cat ON fc.category_id = cat.category_id
            )
            SELECT 
                cs.*,
                cc.favorite_categories,
                RANK() OVER (ORDER BY cs.total_spent DESC) as spending_rank,
                NTILE(4) OVER (ORDER BY cs.total_rentals) as rental_quartile,
                ROUND(cs.total_spent / SUM(cs.total_spent) OVER () * 100, 2) as percentage_of_total_revenue
            FROM customer_spending cs
            JOIN customer_categories cc ON cs.customer_id = cc.customer_id
            WHERE cs.total_rentals > 5
            ORDER BY spending_rank
        `]: new Query<
        {
            customer_id: SqlType<number, 'int4', 'customer_spending.customer_id'>;
            first_name: SqlType<string, 'text', 'customer_spending.first_name'>;
            last_name: SqlType<string, 'text', 'customer_spending.last_name'>;
            total_rentals: SqlType<number, 'bigint', 'customer_spending.total_rentals'>;
            total_spent: SqlType<number, 'bigint', 'customer_spending.total_spent'>;
            avg_payment: SqlType<unknown, 'double precision', 'customer_spending.avg_payment'>;
            favorite_categories: SqlType<Buffer, 'bytea', 'customer_categories.favorite_categories'>;
            spending_rank: SqlType<number, 'bigint', never>;
            rental_quartile: SqlType<number, 'integer', never>;
            percentage_of_total_revenue: SqlType<number, 'numeric', never>;
        },
        never
    >(
        `WITH customer_spending AS (
                SELECT 
                    c.customer_id,
                    c.first_name,
                    c.last_name,
                    COUNT(r.rental_id) as total_rentals,
                    SUM(p.amount) as total_spent,
                    AVG(p.amount) as avg_payment
                FROM customer c
                JOIN rental r ON c.customer_id = r.customer_id
                JOIN payment p ON r.rental_id = p.rental_id
                GROUP BY c.customer_id, c.first_name, c.last_name
            ),
            customer_categories AS (
                SELECT DISTINCT
                    c.customer_id,
                    STRING_AGG(cat.name, ', ') OVER (PARTITION BY c.customer_id) as favorite_categories
                FROM customer c
                JOIN rental r ON c.customer_id = r.customer_id
                JOIN inventory i ON r.inventory_id = i.inventory_id
                JOIN film_category fc ON i.film_id = fc.film_id
                JOIN category cat ON fc.category_id = cat.category_id
            )
            SELECT 
                cs.customer_id, cs.first_name, cs.last_name, cs.total_rentals, cs.total_spent, cs.avg_payment,
                cc.favorite_categories,
                RANK() OVER (ORDER BY cs.total_spent DESC) as spending_rank,
                NTILE(4) OVER (ORDER BY cs.total_rentals) as rental_quartile,
                ROUND(cs.total_spent / SUM(cs.total_spent) OVER () * 100, 2) as percentage_of_total_revenue
            FROM customer_spending cs
            JOIN customer_categories cc ON cs.customer_id = cc.customer_id
            WHERE cs.total_rentals > 5
            ORDER BY spending_rank`,
        [],
    ),
};

export type mpaa_rating = 'G' | 'PG' | 'PG-13' | 'R' | 'NC-17';

export const sqlc = <T extends keyof Queries>(query: T) => queries[query];
